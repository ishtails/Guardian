BACKEND:

------------ DONE ------------
- mongodb users collection has user schema! use db queries for manipulation

- create endpoints / routes for all operations

- create controllers for major actions that manipulate the database directly e.g. GET / POST / PUT of all sorts (getUser, createUser, updateUser etc.)
- a single controller should perform only a single function. input --> output

- create middlewares like auth.js for handling stuff like verifying token or username for reusability

- before logging in - bcrypt handles password hashing during registration & password verification during logging in 

- after logged in -	1. either use jwt access & refresh tokens to verify identity of user for authorization grant to api calls (not safe for sessions afaik)
				    2. else use server session management with cookies e.g. using redis as a cache/session db

- client to server -
	- req.body for attaching data for POST / PUT
	- req.params for having url variables
	- req.query for GET requests of all sorts (sort / filter etc)
	- req.app.locals is used to pass local variables among routes

- reset password flow - pass email as query --> check if email exists --> generate an OTP & send it to email --> take OTP as query and compare with generated one --> create reset session if OTP matches (once) --> PUT / PATCH new password taken as query

- nodemailer & mailgen for sending emails (ethereal account for testing)

------------ DONE ------------

- caching may be implemented to make loading outing data fast by using redis
- fakerjs for generating fake data for testing purposes

FRONTEND:

- create api.ts in frontend and create functions which send api calls to backend for all our needs using fetch/axios 

- zustand (very easy and intuitive) / context-api / redux (overkill, no need) for state store

- separate all react logic into a utils/helper folder.

- combine big hook logics into custom hooks e.g. useFetch(...)

- compress images using "sharp" & convert them to base64 strings for storing in mongoDB..